namespace RentIt

module Auth =

    ///////////////////////////////////////////////////////////////////////

    module internal Internal =

        /// True if the credentials correctly identifies a user, otherwise false
        let validateUserPass user pass = true // Dummy implementation

    ///////////////////////////////////////////////////////////////////////

    module Token =
    
        ///////////////////////////////////////////////////////////////////

        module Date =
            
            let dateFormat = "yyyy-MM-dd HH:mm:ss zzz" // Always 26 characters long

            /// Converts a DateTime date into the string date format used by tokens (UTC)
            let toString (date:System.DateTime) = date.ToString(dateFormat)
                
            /// Converts a date string in the format used by tokens into a DateTime date
            let fromString string = System.DateTime.Parse(string)

        ///////////////////////////////////////////////////////////////////

        module internal Internal =

            let dataSep = " | "
            let cipherFrom = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789/="
            let cipherTo   = "x9/weqrsPcflHIyz012hQMbiNODYtuVZaj3gk45mnvTUopdARS=EWF6G7K8JLBXC"

            // translate message m of alphabet a using the cipher c
            let translate (a:string) (c:string) (m:string) = String.map (fun char -> c.[a.IndexOf(char)]) m
                
            /// Enciphers a base64 encoded string
            let encipher (str:string) = translate cipherFrom cipherTo str
                
            /// Deciphers a base64 encoded string previously enciphered with encipher
            let decipher (str:string) = translate cipherTo cipherFrom str

            /// Obscures a string to make it look like a token (discouraging direct manipulation of it)
            let obscure (string:string) =
                let bytesToEncode = System.Text.Encoding.UTF8.GetBytes(string)
                let encoded = System.Convert.ToBase64String(bytesToEncode)
                encipher encoded
            
            /// Reverses the process done by obscure
            let unobscure (string:string) =
                let base64 = decipher string
                let decodedBytes = System.Convert.FromBase64String(base64)
                System.Text.Encoding.UTF8.GetString(decodedBytes)

            // Given a string this function produces an exactly 10 characters long string representation of its hash code
            let checksum (str:string) =
                let hash = uint32((str).GetHashCode()).ToString()
                "0000000000".Substring(0, 10-hash.Length)+hash // append 0's to create a string of 10 characters

            // Test whether a checksum generated by the checksum function matches the checksum of a string
            let checksumMatches compareSum (str:string) = (checksum str).Equals(compareSum)


        ///////////////////////////////////////////////////////////////////

        /// Authentication token type. user is in lower case!
        type AuthToken = { expires: System.DateTime; user: string }

        /// Creates a new token for {user} which expires in {hours} hours
        let create hours (user:string) =
            let date = System.DateTime.Now.AddHours(float(hours))
            { expires = date; user = user.ToLower() }

        /// True if the token no longer is legal, otherwise false
        let isExpired token = System.DateTime.Now.Ticks >= token.expires.Ticks
    
        /// Encodes a {token} record into a string for transport
        let encode token =
            let date = Date.toString token.expires          // fixed width
            let user = token.user                           // variable width
            let combined = date + Internal.dataSep + user   // yyyy-MM-dd HH:mm:ss zzz | user
            let checksum = Internal.checksum combined
            Internal.obscure checksum + Internal.dataSep + combined
        
        exception IllegalToken

        /// Decodes a {token} string into a token record
        /// Raises an IllegalToken exception if its checksum does not match the content or the token is illegally structured
        let decode token =
            let data = Internal.unobscure token
            
            if data.Length <= 42 then raise IllegalToken // data is missing
            if not (data.Substring(10, 3).Equals(Internal.dataSep) && data.Substring(39, 3).Equals(Internal.dataSep)) then raise IllegalToken // separators at wrong location

            let checksum = data.Substring(0, 10)
            let combined = data.Substring(13)

            if not (Internal.checksumMatches checksum combined) then raise IllegalToken // the token has been tampered with

            let date = Date.fromString (combined.Substring(0, 26))
            let user = combined.Substring(29) // 26+3 = 29

            {expires = date; user = user}

    ///////////////////////////////////////////////////////////////////////

    exception AuthenticationFailed

    /// Retrieves an encoded token for the user {user}, together with an expiration date/time string.
    /// The date/time string is formatted as follows "yyyy-MM-dd HH:mm:ss zzz" e.g. "2013-03-31 23:59:09 +01:00"
    /// Raises AuthenticationFailed if the credentials are incorrect
    /// The result is a tuple: (encodedToken, tokenExpirationString) aka (string * string)
    let authenticate user pass =
        if not (Internal.validateUserPass user pass) then raise AuthenticationFailed
        let token = Token.create 24 user
        (Token.encode token, Token.Date.toString token.expires)