namespace RentIt

module Auth =

    ///////////////////////////////////////////////////////////////////////

    module internal Internal =

        /// True if the credentials correctly identifies a user, otherwise false
        let validateUserPass user pass =
            try
                Account.hasPassword (Account.getByUsername user) pass
            with
                | Account.NoSuchUser -> false

    ///////////////////////////////////////////////////////////////////////

    module Token =

        /// Authentication token type. user is in lower case!
        type AuthToken = { expires: System.DateTime; user: string }

        exception TokenExpired              // Raised if a token is expired and was not supposed to be so
        exception IllegalToken of string    // Raised if a token is malformed
        
        ///////////////////////////////////////////////////////////////////

        module Date =
            
            let dateFormat = "yyyy-MM-dd HH:mm:ss zzz" // Always 26 characters long

            /// Converts a DateTime date into the string date format used by tokens (UTC)
            let toString (date:System.DateTime) = date.ToString(dateFormat)
                
            /// Converts a date string in the format used by tokens into a DateTime date
            let fromString str = System.DateTime.ParseExact(str, dateFormat, System.Globalization.CultureInfo.InvariantCulture)

        ///////////////////////////////////////////////////////////////////

        module internal Internal =

            let dataSep = " | "

            let cipherFrom = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            let cipherTo   = "x9/weqrsPcflHIyz012hQMbiNODYtuVZaj3gk45mnvT+UopdARS=EWF6G7K8JLBXC"

            // translate message m of alphabet a using the cipher c
            let translate (a:string) (c:string) (m:string) =
                let translater (char:char) =
                    let i = a.IndexOf(char)
                    if i < 0 then raise (IllegalToken "Encoded token contained illegal characters")
                    c.[i]
                String.map translater m
                
            /// Enciphers a base64 encoded string
            let encipher (str:string) = translate cipherFrom cipherTo str
                
            /// Deciphers a base64 encoded string previously enciphered with encipher
            let decipher (str:string) = translate cipherTo cipherFrom str

            /// Obscures a string to make it look like a token (discouraging direct manipulation of it)
            let obscure (str:string) =
                let bytesToEncode = System.Text.Encoding.UTF8.GetBytes(str)
                let encoded = System.Convert.ToBase64String(bytesToEncode)
                encipher encoded
            
            /// Reverses the process done by obscure
            let unobscure (str:string) =
                let base64 = decipher str
                let decodedBytes = System.Convert.FromBase64String(base64)
                System.Text.Encoding.UTF8.GetString(decodedBytes)

            // Given a string this function produces an exactly 10 characters long string representation of its hash code
            let checksum (str:string) =
                let hash = uint32((str).GetHashCode()).ToString()
                "0000000000".Substring(0, 10-hash.Length)+hash // append 0's to create a string of 10 characters

            // Test whether a checksum generated by the checksum function matches the checksum of a string
            let checksumMatches compareSum (str:string) = (checksum str).Equals(compareSum)


        ///////////////////////////////////////////////////////////////////

        /// Creates a new token for {user} which expires in {hours} hours
        let create hours (user:string) =
            let date = System.DateTime.Now.AddHours(float(hours))
            { expires = date; user = user }

        /// True if the token no longer is legal, otherwise false
        let isExpired token = System.DateTime.Now.Ticks >= token.expires.Ticks
    
        /// Encodes a {token} record into a string for transport
        let encode token =
            let date = Date.toString token.expires          // fixed width
            let user = token.user                           // variable width
            let combined = date + Internal.dataSep + user   // yyyy-MM-dd HH:mm:ss zzz | user
            let checksum = Internal.checksum combined
            Internal.obscure (checksum + Internal.dataSep + combined)

        /// Decodes a {token} string into a token record
        /// Raises an IllegalToken exception if its checksum does not match the content or the token is illegally structured
        let decode token =
            let data = Internal.unobscure token
            
            if data.Length <= 42 then raise (IllegalToken "Encoded token was malformed: Its length is too short") // data is missing
            if not (data.Substring(10, 3).Equals(Internal.dataSep) && data.Substring(39, 3).Equals(Internal.dataSep)) then raise (IllegalToken "Encoded token was malformed") // separators at wrong location

            let checksum = data.Substring(0, 10)
            let combined = data.Substring(13)

            if not (Internal.checksumMatches checksum combined) then raise (IllegalToken "Encoded token had been tampered with") // the token has been tampered with

            let date = Date.fromString (combined.Substring(0, 26))
            let user = combined.Substring(29) // 26+3 = 29

            {expires = date; user = user}

    ///////////////////////////////////////////////////////////////////////

    exception AuthenticationFailed

    /// Retrieves an encoded token for the user {user}, together with an expiration date/time.
    /// Raises AuthenticationFailed if the credentials are incorrect
    /// The result is a tuple: (encodedToken, tokenExpiration) aka (string * System.DateTime)
    let authenticate user pass =
        if not (Internal.validateUserPass user pass) then raise AuthenticationFailed
        let token = Token.create 24 user // Create a token which lasts for 24 hours
        (Token.encode token, token.expires)

    /// Retrieves the account for which {token} is a reference to.
    /// Raises Auth.Token.IllegalToken if the token is malformed
    /// Raises Auth.Token.TokenExpired if the token has expired
    let accessAccount token =
        let t = Token.decode token
        if (Token.isExpired t) then raise Token.TokenExpired
        Account.getByUsername t.user
